/* tslint:disable */
/* eslint-disable */
/**
 * MusicDataService
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AlbumWriteDto,
  Asset,
  CircleWriteDto,
  HlsPlaylistWriteDto,
  HlsSegmentWriteDto,
  Operation,
  TrackUpdateDto,
  TrackWriteDto,
} from '../models';
import {
    AlbumWriteDtoFromJSON,
    AlbumWriteDtoToJSON,
    AssetFromJSON,
    AssetToJSON,
    CircleWriteDtoFromJSON,
    CircleWriteDtoToJSON,
    HlsPlaylistWriteDtoFromJSON,
    HlsPlaylistWriteDtoToJSON,
    HlsSegmentWriteDtoFromJSON,
    HlsSegmentWriteDtoToJSON,
    OperationFromJSON,
    OperationToJSON,
    TrackUpdateDtoFromJSON,
    TrackUpdateDtoToJSON,
    TrackWriteDtoFromJSON,
    TrackWriteDtoToJSON,
} from '../models';

export interface ApiInternalAlbumAddAlbumIdPutRequest {
    albumId: string;
    parentId?: string;
    albumWriteDto?: AlbumWriteDto;
}

export interface ApiInternalAlbumAlbumIdPatchRequest {
    albumId: string;
    operation?: Array<Operation>;
}

export interface ApiInternalAlbumAlbumIdTrackAddTrackIdPutRequest {
    albumId: string;
    trackId: string;
    trackWriteDto?: TrackWriteDto;
}

export interface ApiInternalAssetAddPutRequest {
    asset?: Asset;
}

export interface ApiInternalAssetTrackTrackIdPlaylistPutRequest {
    trackId: string;
    hlsPlaylistWriteDto?: HlsPlaylistWriteDto;
}

export interface ApiInternalAssetTrackTrackIdSegmentPutRequest {
    trackId: string;
    quality?: number;
    hlsSegmentWriteDto?: HlsSegmentWriteDto;
}

export interface ApiInternalCircleAddIdPutRequest {
    id: string;
    circleWriteDto?: CircleWriteDto;
}

export interface ApiInternalCircleIdPatchRequest {
    id: string;
    operation?: Array<Operation>;
}

export interface ApiInternalTrackJsonpatchTrackIdPatchRequest {
    trackId: string;
    operation?: Array<Operation>;
}

export interface ApiInternalTrackTrackIdPatchRequest {
    trackId: string;
    trackUpdateDto?: TrackUpdateDto;
}

/**
 * 
 */
export class InternalApi extends runtime.BaseAPI {

    /**
     */
    async apiInternalAlbumAddAlbumIdPutRaw(requestParameters: ApiInternalAlbumAddAlbumIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.albumId === null || requestParameters.albumId === undefined) {
            throw new runtime.RequiredError('albumId','Required parameter requestParameters.albumId was null or undefined when calling apiInternalAlbumAddAlbumIdPut.');
        }

        const queryParameters: any = {};

        if (requestParameters.parentId !== undefined) {
            queryParameters['parentId'] = requestParameters.parentId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("Bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/internal/album/add/{albumId}`.replace(`{${"albumId"}}`, encodeURIComponent(String(requestParameters.albumId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AlbumWriteDtoToJSON(requestParameters.albumWriteDto),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiInternalAlbumAddAlbumIdPut(requestParameters: ApiInternalAlbumAddAlbumIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiInternalAlbumAddAlbumIdPutRaw(requestParameters, initOverrides);
    }

    /**
     */
    async apiInternalAlbumAlbumIdPatchRaw(requestParameters: ApiInternalAlbumAlbumIdPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.albumId === null || requestParameters.albumId === undefined) {
            throw new runtime.RequiredError('albumId','Required parameter requestParameters.albumId was null or undefined when calling apiInternalAlbumAlbumIdPatch.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("Bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/internal/album/{albumId}`.replace(`{${"albumId"}}`, encodeURIComponent(String(requestParameters.albumId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.operation.map(OperationToJSON),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiInternalAlbumAlbumIdPatch(requestParameters: ApiInternalAlbumAlbumIdPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiInternalAlbumAlbumIdPatchRaw(requestParameters, initOverrides);
    }

    /**
     */
    async apiInternalAlbumAlbumIdTrackAddTrackIdPutRaw(requestParameters: ApiInternalAlbumAlbumIdTrackAddTrackIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.albumId === null || requestParameters.albumId === undefined) {
            throw new runtime.RequiredError('albumId','Required parameter requestParameters.albumId was null or undefined when calling apiInternalAlbumAlbumIdTrackAddTrackIdPut.');
        }

        if (requestParameters.trackId === null || requestParameters.trackId === undefined) {
            throw new runtime.RequiredError('trackId','Required parameter requestParameters.trackId was null or undefined when calling apiInternalAlbumAlbumIdTrackAddTrackIdPut.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("Bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/internal/album/{albumId}/track/add/{trackId}`.replace(`{${"albumId"}}`, encodeURIComponent(String(requestParameters.albumId))).replace(`{${"trackId"}}`, encodeURIComponent(String(requestParameters.trackId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: TrackWriteDtoToJSON(requestParameters.trackWriteDto),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiInternalAlbumAlbumIdTrackAddTrackIdPut(requestParameters: ApiInternalAlbumAlbumIdTrackAddTrackIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiInternalAlbumAlbumIdTrackAddTrackIdPutRaw(requestParameters, initOverrides);
    }

    /**
     */
    async apiInternalAssetAddPutRaw(requestParameters: ApiInternalAssetAddPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("Bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/internal/asset/add`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AssetToJSON(requestParameters.asset),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiInternalAssetAddPut(requestParameters: ApiInternalAssetAddPutRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiInternalAssetAddPutRaw(requestParameters, initOverrides);
    }

    /**
     */
    async apiInternalAssetTrackTrackIdPlaylistPutRaw(requestParameters: ApiInternalAssetTrackTrackIdPlaylistPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.trackId === null || requestParameters.trackId === undefined) {
            throw new runtime.RequiredError('trackId','Required parameter requestParameters.trackId was null or undefined when calling apiInternalAssetTrackTrackIdPlaylistPut.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("Bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/internal/asset/track/{trackId}/playlist`.replace(`{${"trackId"}}`, encodeURIComponent(String(requestParameters.trackId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: HlsPlaylistWriteDtoToJSON(requestParameters.hlsPlaylistWriteDto),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiInternalAssetTrackTrackIdPlaylistPut(requestParameters: ApiInternalAssetTrackTrackIdPlaylistPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiInternalAssetTrackTrackIdPlaylistPutRaw(requestParameters, initOverrides);
    }

    /**
     */
    async apiInternalAssetTrackTrackIdSegmentPutRaw(requestParameters: ApiInternalAssetTrackTrackIdSegmentPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.trackId === null || requestParameters.trackId === undefined) {
            throw new runtime.RequiredError('trackId','Required parameter requestParameters.trackId was null or undefined when calling apiInternalAssetTrackTrackIdSegmentPut.');
        }

        const queryParameters: any = {};

        if (requestParameters.quality !== undefined) {
            queryParameters['quality'] = requestParameters.quality;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("Bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/internal/asset/track/{trackId}/segment`.replace(`{${"trackId"}}`, encodeURIComponent(String(requestParameters.trackId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: HlsSegmentWriteDtoToJSON(requestParameters.hlsSegmentWriteDto),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiInternalAssetTrackTrackIdSegmentPut(requestParameters: ApiInternalAssetTrackTrackIdSegmentPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiInternalAssetTrackTrackIdSegmentPutRaw(requestParameters, initOverrides);
    }

    /**
     */
    async apiInternalCircleAddIdPutRaw(requestParameters: ApiInternalCircleAddIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiInternalCircleAddIdPut.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("Bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/internal/circle/add/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: CircleWriteDtoToJSON(requestParameters.circleWriteDto),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiInternalCircleAddIdPut(requestParameters: ApiInternalCircleAddIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiInternalCircleAddIdPutRaw(requestParameters, initOverrides);
    }

    /**
     */
    async apiInternalCircleIdPatchRaw(requestParameters: ApiInternalCircleIdPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiInternalCircleIdPatch.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("Bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/internal/circle/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.operation.map(OperationToJSON),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiInternalCircleIdPatch(requestParameters: ApiInternalCircleIdPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiInternalCircleIdPatchRaw(requestParameters, initOverrides);
    }

    /**
     */
    async apiInternalTrackJsonpatchTrackIdPatchRaw(requestParameters: ApiInternalTrackJsonpatchTrackIdPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.trackId === null || requestParameters.trackId === undefined) {
            throw new runtime.RequiredError('trackId','Required parameter requestParameters.trackId was null or undefined when calling apiInternalTrackJsonpatchTrackIdPatch.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("Bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/internal/track/jsonpatch/{trackId}`.replace(`{${"trackId"}}`, encodeURIComponent(String(requestParameters.trackId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.operation.map(OperationToJSON),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiInternalTrackJsonpatchTrackIdPatch(requestParameters: ApiInternalTrackJsonpatchTrackIdPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiInternalTrackJsonpatchTrackIdPatchRaw(requestParameters, initOverrides);
    }

    /**
     */
    async apiInternalTrackTrackIdPatchRaw(requestParameters: ApiInternalTrackTrackIdPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.trackId === null || requestParameters.trackId === undefined) {
            throw new runtime.RequiredError('trackId','Required parameter requestParameters.trackId was null or undefined when calling apiInternalTrackTrackIdPatch.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("Bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/internal/track/{trackId}`.replace(`{${"trackId"}}`, encodeURIComponent(String(requestParameters.trackId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: TrackUpdateDtoToJSON(requestParameters.trackUpdateDto),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiInternalTrackTrackIdPatch(requestParameters: ApiInternalTrackTrackIdPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiInternalTrackTrackIdPatchRaw(requestParameters, initOverrides);
    }

}
